<!DOCTYPE html>
<html
  class=""
  lang="en-us"
  prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"
>
  <head>
    <meta charset="utf-8" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="description" content="" />
<meta name="HandheldFriendly" content="True" />
<meta name="MobileOptimized" content="320" />
<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="keywords" content="música,
">


<meta property="og:type" content="article" />
<meta property="og:description" content="" />
<meta property="og:title" content="Afinación pitagórica" />
<meta property="og:site_name" content="Full and Faithful" />
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="https://fullandfaithful.com/posts/well-formed-scales/" />
<meta property="og:locale" content="en-us" />
<meta property="article:published_time" content="2022-05-14
" /> <meta property="article:modified_time" content="2022-05-14
" />


<meta property="article:tag" content="música" />






    <title>Afinación pitagórica</title>
    <link rel="canonical" href="https://fullandfaithful.com/posts/well-formed-scales/" />


    <link
  rel="stylesheet"
  href="https://unpkg.com/tachyons@4.11.1/css/tachyons.min.css"
/>

<link rel="stylesheet" href="https://fullandfaithful.com/css/style.css" />

<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/highlightjs@9.12.0/styles/github-gist.css"
/>


<script type="application/javascript">
var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
var doNotTrack = (dnt == "1" || dnt == "yes");
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	if (window.sessionStorage) {
		var GA_SESSION_STORAGE_KEY = 'ga:clientId';
		ga('create', 'UA-XXXXXXXXX-X', {
	    'storage': 'none',
	    'clientId': sessionStorage.getItem(GA_SESSION_STORAGE_KEY)
	   });
	   ga(function(tracker) {
	    sessionStorage.setItem(GA_SESSION_STORAGE_KEY, tracker.get('clientId'));
	   });
   }
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  </head>


<body
  lang="en-us"
  class="sans-serif w-90 w-60-ns center center-ns mv2 mv5-ns"
  itemscope
  itemtype="http://schema.org/Article"
>
  
  <span class="b">/ </span>
  <a
    href="https://fullandfaithful.com/"
    class="b bb bw1 pb1 no-underline black"
    >Full and Faithful</a
  >

  <section id="main" class="mt5">
    <h1 itemprop="name" id="title">Afinación pitagórica</h1>

    <article itemprop="articleBody" id="content" class="w-90 lh-copy">
      <p>Un instrumento de cuerdas, por ejemplo, un piano, produce sonido vibrando cuerdas a diferentes frecuencias. Para escoger a qué frecuencia vibra cada cuerda utilizamos algún proceso que llamamos <em>sistema de afinación</em>. Existen muchos sistemas de afinación pero en esta pequeña notita nos enfocaremos en el sistema de afinación pitagórico. Este consiste en fijar una frecuencia base y multiplicarla por \(3/2\) para obtener una segunda frecuencia. A esta segunda frecuencia la volvemos a multiplicar por \(3/2\) para obtener una tercera y así sucesivamente hasta conseguir \(12\) frecuencias que corresponden a las notas que conocemos en la escala cromática. Si empezamos el proceso en fa, obtenemos el conjunto fa, do, sol, re, la, mi, si, fa#, do#, sol#, re#, y la#, en ese orden. A esta sucesión la conocemos como el <em>círculo de quintas</em>.</p>
<p>El proceso no termina del todo ahí puesto que por convención las notas que están a una razón de \(2/1\) de distancia entre ellas se consideran la mismas nota. Es decir, \(fa \times 2\) es de nuevo \(fa\). Decimos que \(fa\) y \(fa \times 2\) están en la misma <em>clase tonal</em> (<em>pitch class</em>) y decimos que \(fa \times 2\) está a una octava de distancia de \(fa\). Así surge la convención de asignar números a cada octava, por ejemplo, en la afinación convencional la frecuencia de \(440\) se llama \(la_4\), que implica que \(220\) es \(la_3\), \(880\) es \(la_5\) y así sucesivamente multiplicandoo por potencias de \(2\).</p>
<p>Entonces, en corto, el proceso que seguimos para afinar todas las notas en un piano consiste en conseguir un representante de cada clase tonal apilando quintas y de rellenar cada octava con representantes de las clases tonales dentro de cada octava.</p>
<p>Podemos generalizar el proceso abriendonos a la posibilidad de que las quintas sean no sólo de razón \(3/2\). Si \(\mu\) es un número racional entre \(2^{1/2}\) (el tritono) y \(2\) (la octava), el <em>sistema pitagórico generalizado asociado a</em> \(\mu\) es \(P_{\mu} = \{\mu^{b} \mid b \in \mathbb{N}\}\). Es decir, \(P_{\mu}\) es el conjunto de todas las razones necesarias por las cuales hay que multiplicar alguna frecuencia base para computar todas las clases tonales posibles. En otras palabras, un elemento \(\mu^{b} \in P_{\mu}\) está asociado a la clase tonal que se encuentra a \(b\) quintas de distancia de la frecuencia inicial.</p>
<p>Puesto que nuestra convención es llamar de la misma manera a las notas que están a una potencia de \(2\) de distancia, hay que poner particular atención a los sistemas que contiene quintas que son potencias racionales de \(2\). Si \(\mu = 2^{M/N}\) entonces podemos identificar a \(P_{\mu}\) con \(Z_N\) pues \(2^a\mu^b\) está en la misma clase tonal de \(2^c\mu^d\) sí y sólo si \(b \equiv_{mod\ N}d\) dado que \(2^a\mu^{tN+r}=2^{a+Mt}\mu^r\). O sea, uno puede identificar naturalmente a \(P_{\mu}\) con \(\mathbb{Z}\) o con \(\mathbb{Z}_N\) con la función \(\mu^b \mapsto b\).</p>
<h3 id="haciendo-un-mini-programita">Haciendo un mini programita</h3>
<p>Con el interés de calcular algunos sistemas pitagóricos generalizados podemos hacer un programita que nos calcule las frecuencias automáticamente. Lo hacemos en Lisp porque Lisp es mi lenguaje de programación preferido pero también lo voy a traducir a python porque python es muy popular y si te interesa al menos un poco la programación es probable que puedas leer python aunque no tentas tanta fuidez al leer Lisp.</p>
<p>Para representar un sistema pitagórico en Lisp es muy sencillo. Lo podemos hacer con una clausura léxica. Definimos una variable con alcance léxico en la que guardamos el valor de nuestra quinta formal. Luego regresamos una función que eleva a la potencia \(n\) nuestro valor \(\mu\):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun pysys (mu)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let</span> ((m mu))
</span></span><span style="display:flex;"><span>    (lambda (b) (<span style="color:#a6e22e">expt</span> m b))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (pysys <span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>&lt;FUNCTION (LAMBDA (B) <span style="color:#e6db74">:IN</span> PYSYS) {70084A8DEB}&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (<span style="color:#a6e22e">funcall</span> <span style="color:#a6e22e">*</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt;
</span></span></code></pre></div><p>Así que la función <code>pysys</code> (por pythagorean system), dada una \(\mu\), regresa el sistema pitagórico asociado a \(\mu\). En python se puede escribir de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pySys</span>(mu):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">lambda</span> b: (mu <span style="color:#f92672">**</span> b))
</span></span></code></pre></div><p>ahora bien, para tener una implementación completa de nuestro proceso de afinación necesitamos una función que ponga las clases tonales dentro de una octava. Esta también es muy sencilla. Va a recibir, primero una frecuencia arbitraria \(f\) y luego una frequencia base \(r\), si la frecuencia \(f\) se encuentra más cerca que una octava de \(r\) regresamos la misma frecuencia \(f\), pero si no, dividimos entre o multiplicamos por \(2\) la frecuencia \(f\) para acercarla a la octava. La función en Lisp queda así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun octavize (freq root)
</span></span><span style="display:flex;"><span>  (cond
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">&gt;</span> freq (<span style="color:#a6e22e">*</span> root <span style="color:#ae81ff">2</span>)) (octavize (<span style="color:#a6e22e">/</span> freq <span style="color:#ae81ff">2</span>) root))
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">&lt;</span> freq root) (octavize (<span style="color:#a6e22e">*</span> freq <span style="color:#ae81ff">2</span>) root))
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">t</span> freq)))
</span></span></code></pre></div><p>en python podemos hacer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">octavize</span>(freq, root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> freq <span style="color:#f92672">&gt;</span> (root <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> octavize(freq <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, root)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> freq <span style="color:#f92672">&lt;</span> root:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> octavize(freq <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, root)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> freq
</span></span></code></pre></div><p>Para calcular algunas frecuencias símplemente fijamos algúna frecuencia base, digamos&hellip; \(la = 440 Hz\) y multiplicamos por nuestro sistema pitagórigo. En este ejemplo conseguimos el sistema pitagórico asociado a \(1.5= \frac{3}{2}\) con nuestra función <code>pysys</code> y luego multiplicamos la frecuencia \(440\) por el sistema en \(1\).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (pysys <span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>&lt;FUNCTION (LAMBDA (B) <span style="color:#e6db74">:IN</span> PYSYS) {70089EF29B}&gt;
</span></span><span style="display:flex;"><span>CL-USER&gt; (<span style="color:#a6e22e">*</span> <span style="color:#ae81ff">440</span> (<span style="color:#a6e22e">funcall</span> <span style="color:#a6e22e">*</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">660.0</span>
</span></span></code></pre></div><p>Para hacer las cosas más rápido podemos hacer una función como la siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun collect-n-ratios (n mu)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let</span> ((sys (py-sys mu)))
</span></span><span style="display:flex;"><span>    (loop for i from <span style="color:#ae81ff">0</span> to (<span style="color:#a6e22e">-</span> n <span style="color:#ae81ff">1</span>) collecting
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">funcall</span> sys <span style="color:#ae81ff">0</span> i))))
</span></span></code></pre></div><p>Esta función calcula \(n\) elementos del sistema pitagórico asociado a \(\mu\):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (collect-n-ratios <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1.0</span> <span style="color:#ae81ff">1.5</span> <span style="color:#ae81ff">2.25</span> <span style="color:#ae81ff">3.375</span> <span style="color:#ae81ff">5.0625</span> <span style="color:#ae81ff">7.59375</span> <span style="color:#ae81ff">11.390625</span>)
</span></span></code></pre></div><p>y para calcular algunas frecuencias basta utilizar <code>mapcar</code> en la lista que obtenemos con <code>collect-n-ratios</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun generate-scale (r n mu)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">mapcar</span> (lambda (x) (<span style="color:#a6e22e">*</span> r x))
</span></span><span style="display:flex;"><span>          (collect-n-ratios n mu)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun generate-scale-octavized (r n mu)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">mapcar</span> (lambda (x) (octavize x r))
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">mapcar</span> (lambda (x) (<span style="color:#a6e22e">*</span> r x))
</span></span><span style="display:flex;"><span>                  (collect-n-ratios n mu))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (generate-scale-octavized <span style="color:#ae81ff">440</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">440.0</span> <span style="color:#ae81ff">660.0</span> <span style="color:#ae81ff">495.0</span> <span style="color:#ae81ff">742.5</span> <span style="color:#ae81ff">556.875</span> <span style="color:#ae81ff">835.3125</span> <span style="color:#ae81ff">626.4844</span>)
</span></span></code></pre></div><p>En python podemos hacerlo de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stackFifths</span>(root, ratio, times):
</span></span><span style="display:flex;"><span>    lst <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(times):
</span></span><span style="display:flex;"><span>        lst<span style="color:#f92672">.</span>insert(<span style="color:#ae81ff">0</span>, ratio <span style="color:#f92672">**</span> i)
</span></span><span style="display:flex;"><span>    lst<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>    lst <span style="color:#f92672">=</span> list(map(<span style="color:#66d9ef">lambda</span> x : x <span style="color:#f92672">*</span> root, lst))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lst
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generateScale</span>(root, ratio, times):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(map(<span style="color:#66d9ef">lambda</span> x : octavize (x, root), stackFifths(root,ratio,times)))
</span></span></code></pre></div><h2 id="escalas-bien-formadas">Escalas bien formadas</h2>
<p>Pero ¿Cuántas notas generar? ¿Hay algúna razón por la cual no generar 8 notas?. Por ejemplo, tenemos en la música occidental la escala pentatónica, la escala diatónica y la cromática, pero nuestros sistemas pitagóricos nos ofrecen infinitas notas, bueno, al menos los que no son potencias racionales de \(2\). ¿Existe alguna propiedad notable en los números \(5\), \(7\), y \(12\)?, nos preguntamos ¿Existen números buenos \(n\) para generar escalas de \(n\) clases tonales?. Bueno, pues las escalas pentatónica, diatónica y cromática cumplen una propiedad bastante simpática. Si primero las generamos apilando quintas y las ordenamos en un círculo, obtenemos un polígono de \(5\), \(7\) o \(12\) lados. Pero si después las conectamos de tal manera que se sigue un orden de escala se preserva la simetría del polígono.</p>
<figure><img src="/images/Image002.png"/>
</figure>

<p>Si a estas notas las re-etiquetamos de tal manera que sus nombres sean los elementos de \(\mathbb{Z}_N\) entonces veremos que el hecho de que preserven las simetrías tiene que ver con que exista un automorfismo \(\mathbb{Z}_N \to \mathbb{Z}_N\) que las ordene en orden de escala. No está dentro del alcance de esta notita demostrar el siguiente teorema pero lo citamos de todas maneras porque es, además de muy lindo, lo que responde las preguntas del párrafo anterior. El teorema lo saqué del <a href="https://www.researchgate.net/publication/215646485_Aspects_of_Well-Formed_Scales">artículo del que saqué todo esto</a>.</p>
<p><strong>Teorema:</strong> Sea \(\mu\) una quinta formal y \(Z_B = 0, \ldots, B-1\) las classes tonales dentro del sistema asociado a \(\mu\). El conjunto \(Z_B\) es una <strong>escala bien formada</strong> si y sólo si \(\frac{A}{B}\) es un (semi)convergente en la expansión en fracción continua de \(log_2(\mu)\) y el automorfismo que pone en orden de escala a \(Z_B\) es:</p>
<p>\[\omega_B: Z_B \to Z_B: z \mapsto zb_k (-1)^k\]</p>
<p>en donde \(\frac{a_k}{b_k}\) es el convergente completo anterior a \(\frac{A}{B}\).</p>
<h3 id="ejemplo-1">Ejemplo 1</h3>
<p>Como ejemplo calculamos las escalas bien formadas de \(\mu = 3/2\). Tenemos que la expansión en fracción continua de \(log_2(3/2)\) es \(log_(3/2)=[0,1, 1, 2, 2, 3, 1, 5, 2, 23, 2, 2, 1, 1, 55, 1, 4]\). Entonces la suceción de (semi)convergentes empezando en \(k = 1\) es: \([0,1]=1,[0,1,1]=\frac{1}{2}\),
\([0,1,1,1]=\frac{2}{3}\), \([0,1,1,2]=\frac{3}{5}\), \([0,1,1,2,1]=\frac{4}{7}\), \([0,1,1,2,2]=\frac{7}{12}\), \([0,1,1,2,2,1]=\frac{10}{17}\), y así sucesivamente. De tal manera que las escalas bien formadas asociadas a \(\mu = 1.5\) son las que tienen $1,2,3,5,7,12,17,&hellip;$ notas.</p>
<p>Consideremos ahora la escala pentatónica representada por \(\mathbb{Z}_5\). Si comenzamos en fa a apilar quintas obtenemos fa do sol re la. En la escala pentatónica el convergente que nos da el 5 es \([0,1,1,2]=\frac{3}{5}\) y el convergente anterior completo es \([0,1,1]= \frac{1}{2}\) por lo tanto el automorfismo que pone las notas fa do sol re la en orden de escala debe ser \(z \mapsto z2(-1)^2_{mod\ 5}= z2_{mod\ 5}\)</p>
<table>
<thead>
<tr>
<th>solfeo</th>
<th>\(z\)</th>
<th>\(2z\)</th>
<th>\(2z _{mod\ 5}\)</th>
<th>solfeo</th>
</tr>
</thead>
<tbody>
<tr>
<td>fa</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>fa</td>
</tr>
<tr>
<td>do</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>sol</td>
</tr>
<tr>
<td>sol</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>la</td>
</tr>
<tr>
<td>re</td>
<td>3</td>
<td>6</td>
<td>1</td>
<td>do</td>
</tr>
<tr>
<td>la</td>
<td>4</td>
<td>8</td>
<td>3</td>
<td>re</td>
</tr>
</tbody>
</table>
<figure><img src="/images/Image003.png"/>
</figure>

<p>para \(B = 7\) el convergente es de hecho el semiconvergente \([0,1,1,2,1]= \frac{4}{7}\) y el convergente anterior es \([0,1,1,2]= \frac{3}{5}\). Por lo tanto el automorfismo que acomoda las notas en orden de escala es \(z \mapsto z5(-1)^3_{mod\ 7}= -5z _{mod\ 7} = 2 z_{mod\ 7}\). Ahora, si apilamos quintas en fa obtenemos fa do sol re la mi si y la tabla queda:</p>
<table>
<thead>
<tr>
<th>solfeo</th>
<th>\(z\)</th>
<th>\(2z\)</th>
<th>\(2z _{mod\ 7}\)</th>
<th>solfeo</th>
</tr>
</thead>
<tbody>
<tr>
<td>fa</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>fa</td>
</tr>
<tr>
<td>do</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>sol</td>
</tr>
<tr>
<td>sol</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>la</td>
</tr>
<tr>
<td>re</td>
<td>3</td>
<td>6</td>
<td>6</td>
<td>si</td>
</tr>
<tr>
<td>la</td>
<td>4</td>
<td>8</td>
<td>1</td>
<td>do</td>
</tr>
<tr>
<td>mi</td>
<td>5</td>
<td>10</td>
<td>3</td>
<td>re</td>
</tr>
<tr>
<td>si</td>
<td>6</td>
<td>12</td>
<td>5</td>
<td>mi</td>
</tr>
</tbody>
</table>
<figure><img src="/images/Image004.png"/>
</figure>

<h3 id="ejemplo-2">Ejemplo 2</h3>
<p>Ahora calculamos la tabla para \(9\) EDO (equal divisions of octave, es decir, divisiones iguales de la octava) \(\mu = 2^{5/9}\). La expansión de \(log_2(2^{5/9})\) es \([1,1,4]\) y la secuencia de (semi-)convergentes es: \([0,1]=1\), \([0,1,1]=\frac{1}{2}\), \([0,1,1,1]=\frac{2}{3}\), \([0,1,1,2]=\frac{3}{5}\), \([0,1,1,3]=\frac{4}{7}\), \([0,1,1,4]=\frac{5}{9}\). Para la escala de \(5\) representada por \(\mathbb{Z}_B\) el automorfismo que buscamos es \(z\mapsto z2_{mod 5}\)</p>
<table>
<thead>
<tr>
<th>solfeo</th>
<th>\(z\)</th>
<th>\(2z\)</th>
<th>\(2z mod 5\)</th>
<th>solfeo</th>
</tr>
</thead>
<tbody>
<tr>
<td>fa</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>fa</td>
</tr>
<tr>
<td>do</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>sol</td>
</tr>
<tr>
<td>sol</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>la</td>
</tr>
<tr>
<td>re</td>
<td>3</td>
<td>6</td>
<td>1</td>
<td>do</td>
</tr>
<tr>
<td>la</td>
<td>4</td>
<td>8</td>
<td>3</td>
<td>re</td>
</tr>
</tbody>
</table>
<p>y para la escala de 9 tonos tenemos la siguiente tabla:</p>
<table>
<thead>
<tr>
<th>solfeo</th>
<th>\(z\)</th>
<th>\(2z\)</th>
<th>\(2z mod 9\)</th>
<th>solfeo</th>
</tr>
</thead>
<tbody>
<tr>
<td>fa</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>fa</td>
</tr>
<tr>
<td>do</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>sol</td>
</tr>
<tr>
<td>sol</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>la</td>
</tr>
<tr>
<td>re</td>
<td>3</td>
<td>6</td>
<td>6</td>
<td>si</td>
</tr>
<tr>
<td>la</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>bet</td>
</tr>
<tr>
<td>mi</td>
<td>5</td>
<td>10</td>
<td>1</td>
<td>do</td>
</tr>
<tr>
<td>si</td>
<td>6</td>
<td>12</td>
<td>3</td>
<td>re</td>
</tr>
<tr>
<td>al</td>
<td>7</td>
<td>14</td>
<td>5</td>
<td>mi</td>
</tr>
<tr>
<td>bet</td>
<td>8</td>
<td>16</td>
<td>7</td>
<td>al</td>
</tr>
</tbody>
</table>
<p>en donde <em>al</em> y <em>bet</em> son las primeras sílabas de <em>alfa</em> y <em>beta</em> que usamos aquí para extender el sistema de solfeo normal.</p>
<figure><img src="/images/Image005.png"/>
</figure>

<h2 id="afinación-en-kontakt">Afinación en Kontakt</h2>
<p>Ahora explicamos un poquito cómo escuchar estas escalas. Una manera sencilla y, por supuesto muy útil, que hay para escuchar estas escalas es haciendo un script para el sampler <a href="https://www.native-instruments.com/en/products/komplete/samplers/kontakt-6/">kontakt</a>. Para esto, utilizaremos la herramienta <a href="https://sevish.com/scaleworkshop/">scale workshop</a>. Esa app nos permite, entre otras cosas, especificar en el espacio todas las razones entre las notas de una escala y exportarla en varios formatos, entre ellos, el de afinación en kontakt.</p>
<p>Para entrar manualmente las razones de una escala, scale workshop acepta diferentes notaciones. Los números que contienen un punto <code>.</code> son cents, los números que contienen una diagonal <code>/</code> son razones, los que están escritos en el formato <code>n\m</code> son \(n\) grados de \(m\) divisiones iguales de octava. El último número se refiere a la <em>octava formal</em> sea octava <code>2/1</code> o lo que llaman una <em>pseudo octava</em>.</p>
<p>Aprovechando que hicimos un programita para calcular las frecuencias me parece más cómodo convertir los sistemas que calculamos a cents. Recordemos que un <em>cent</em> es una centésima división de una doceava división igual de octava, es decir que la razón en cents entre una frecuencia \(f_1\) y otra \(f_2\) está dada por:</p>
<p>\[c =  log_2(\frac{f_2}{f_1})*1200\]</p>
<p>con esta formula podemos definir una función <code>inCents</code> que reciba dos frecuencias y nos dé la razón en cents entre ellas:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inCents</span>(f1,f2):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> math<span style="color:#f92672">.</span>log(f2 <span style="color:#f92672">/</span> f1, <span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">1200</span>
</span></span></code></pre></div><p>y podemos mapear esta función a una lista de frecuencias:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">scaleInCents</span>(freqlist,root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(map(<span style="color:#66d9ef">lambda</span> x: inCents(root, x), freqlist))
</span></span></code></pre></div><p>En lisp podemos hacer algo similar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun generate-diatonic (root <span style="color:#a6e22e">ratio</span> times)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">mapcar</span> (lambda (x) (octavize x root))
</span></span><span style="display:flex;"><span>          (stack-fifths root <span style="color:#a6e22e">ratio</span> times)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun in-cents (f1 f2)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">*</span> <span style="color:#ae81ff">1200</span>
</span></span><span style="display:flex;"><span>     (<span style="color:#a6e22e">log</span> (<span style="color:#a6e22e">/</span> f2 f1) <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun diatonic-in-cents (freq-list root)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">mapcar</span> (lambda (x) (in-cents root x))
</span></span><span style="display:flex;"><span>          freq-list))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun generate-in-cents (<span style="color:#a6e22e">ratio</span> times)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">cdr</span>
</span></span><span style="display:flex;"><span>   (diatonic-in-cents
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">sort</span> (generate-diatonic <span style="color:#ae81ff">1</span> <span style="color:#a6e22e">ratio</span> times) <span style="color:#a6e22e">#&#39;&lt;</span>) <span style="color:#ae81ff">1</span>)))
</span></span></code></pre></div><p>Por ejemplo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-common-lisp" data-lang="common-lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CL-USER&gt; (generate-in-cents <span style="color:#ae81ff">1.5</span> <span style="color:#ae81ff">17</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">23.46001</span> <span style="color:#ae81ff">113.685</span> <span style="color:#ae81ff">203.90999</span> <span style="color:#ae81ff">227.37</span> <span style="color:#ae81ff">317.595</span> <span style="color:#ae81ff">407.81998</span> <span style="color:#ae81ff">431.27997</span> <span style="color:#ae81ff">521.505</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">611.73004</span> <span style="color:#ae81ff">701.95496</span> <span style="color:#ae81ff">725.41504</span> <span style="color:#ae81ff">815.63995</span> <span style="color:#ae81ff">905.8649</span> <span style="color:#ae81ff">929.3251</span> <span style="color:#ae81ff">1019.55</span> <span style="color:#ae81ff">1109.775</span>)
</span></span></code></pre></div><p>Ahora podemos usar scale workshop para anotar todas nuestras razones y exportarlas en formato <code>kontakt tuning script</code></p>
<figure><img src="/images/sw1.png"/>
</figure>

<p>Ahora lo único que hay que hacer es poner el script en una tab vacía del editor de scripts de Kontakt como se muestra aquí:</p>
<figure><img src="/images/skw1.gif"/>
</figure>


    </article>
  </section>

  <footer>
    <div>
      <p class="f6 gray mt6 lh-copy">
        
      </p>
    </div>
  </footer>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>

<script>
  hljs.initHighlightingOnLoad();
</script>


  

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


  </body>
</html>
